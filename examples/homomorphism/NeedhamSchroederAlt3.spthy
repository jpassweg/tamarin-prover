// NEEDHAM-SCHROEDER SYMMETRIC KEY PROTOCOL from the Cap Unification paper

// LOOK OUT!! IN FACTS STILL USE FRESH VALUES
// EVERYTHING IN NORMAL FORM

theory NeedhamSchroederAlternativeProtocol3
begin

/*
Alternative Protocol:
A->S: A, B, N_a
S->A: {N_a, B, K_ab}Kas
S->B: {K_ab,A}Kbs
B->A: {N_b}Kab
A->B: {succ(N_b)}Kab
*/

builtins: homomorphic-encryption
functions: succ/1

rule Client_Server_Keys:
    [ Fr(~key) ]
    --[]->
    [ SCKey($Server, $Client, ~key), CSKey($Client, $Server, ~key) ]

rule A_1:
    [ CSKey($A, $S, KAS)
    , Fr(~NA) ]
    --[ GenerateNA(~NA) ]->
    [ A1Out(<<$A, $B>, ~NA>)
    , RevealA1(<<$A, $B>, ~NA>)
    , A_1_State($S, $A, $B, KAS, ~NA) ]

rule Reveal:
    [ RevealA1(<<$A, $B>, ~NA>) ]
    -->
    [ Out(<<$A, $B>, ~NA>) ]

rule S_1:
    [ SCKey($S, $A, KAS)
    , SCKey($S, $B, KBS)
    , A1Out(<<$A, $B>, NA>)
    , Fr(~KAB) ]
    --[ ReceiveNA(NA) ]->
    [ Out(<<henc(NA, KAS), henc($B, KAS)>, henc(~KAB, KAS)>)
    , Out(<henc(~KAB, KBS), henc($A, KBS)>) ]

rule A_2:
    [ A_1_State($S, $A, $B, KAS, ~NA)
    , In(<<henc(~NA, KAS), henc($B, KAS)>, henc(~KAB, KAS)>) ]
    --[]->
    [ A_2_State($S, $A, $B, KAS, ~KAB) ]

rule B_1:
    [ CSKey($B, $S, KBS)
    , In(<henc(~KAB, KBS), henc($A, KBS)>)
    , Fr(~NB) ]
    --[]->
    [ Out(henc(~NB, ~KAB)) 
    , B_1_State($S, $A, $B, KBS, ~KAB, ~NB) ]

rule A_3:
    [ A_2_State($S, $A, $B, KAS, KAB)
    , In(henc(~NB, KAB)) ]
    --[ NotEqual(KAB, $A)
      , NotEqual(KAB, $B)
      , NotEqual(KAB, $S)
      , SecretKey($A, KAB)
      , FinishedA($A, $B, KAB) ]->
    [ Out(henc(succ(~NB), KAB)) ]

rule B_2:
    [ B_1_State($S, $A, $B, KBS, KAB, ~NB)
    , In(henc(succ(~NB), KAB)) ]
    --[ NotEqual(KAB, $A)
      , NotEqual(KAB, $B)
      , NotEqual(KAB, $S)
      , SecretKey($B, KAB)
      , FinishedB($B, $A, KAB) ]->
    []


restriction notEqual:
    "All a #t. NotEqual(a,a) @t ==> F"

    /*
lemma forwardna [sources]:
    "All NA #i. ReceiveNA(NA) @i ==> (Ex #t. GenerateNA(NA) @t & (#t < #i)) | (Ex #t. K(NA) @t & (#t < #i))"
*/

lemma Executability_Lemma:
    exists-trace "Ex A B key #i #j. FinishedA(A, B, key) @i & FinishedB(B, A, key) @j & not (A = B)"

lemma Secret_Shared_Key: 
    "All agent key #i. SecretKey(agent, key) @ #i ==> (not (Ex #t. K(key) @ #t))"

end