// NEEDHAM-SCHROEDER SYMMETRIC KEY PROTOCOL from the Cap Unification paper

theory NeedhamSchroeder
begin

builtins: homomorphic-encryption
functions: succ/1

rule Client_Server_Keys:
    [ Fr(~key) ]
    --[]->
    [ SCKey($Server, $Client, ~key), CSKey($Client, $Server, ~key) ]

rule A_1:
    [ Fr(~NA) ]
    --[]->
    [ Out(<<$A, $B>, ~NA>)
    , A_1_State($A, $B, ~NA) ]

rule S_1:
    [ SCKey($S, $A, KAS)
    , SCKey($S, $B, KBS)
    , In(<<$A, $B>, NA>)
    , Fr(~KAB) ]
    --[ NotEqual($A, $B)
      , NotEqual($A, NA)
      , NotEqual($B, NA)
      , NotEqual($S, NA)
      , NotEqual(KAS, NA)
      , NotEqual(KBS, NA)
      , SentToForward($S, $A, $B, henc(~KAB, KBS), henc($A, KBS))
      , Sent($S, $A, henc(NA, KAS))
      , Sent($S, $A, henc($B, KAS))
      , Sent($S, $A, henc(~KAB, KAS))
      , Sent($S, $A, henc(henc(~KAB, KBS), KAS))
      , Sent($S, $A, henc(henc($A, KBS), KAS))
      , WrongForward($S, $B, henc(~KAB, KBS))
      , WrongForward($S, $B, henc($A, KBS)) ]->
    [ Out(henc(<<<NA, $B>, ~KAB>, henc(<~KAB, $A>, KBS)>, KAS)) ]

rule A_2:
    [ A_1_State($A, $B, ~NA)
    , CSKey($A, $S, KAS)
    , In(henc(<<<~NA, $B>, KAB>, <SBMsg1, SBMsg2>>, KAS)) ]
    --[ NotEqual($A, $B)
      , NotEqual(KAB, $S)
      , NotEqual(KAB, $A) 
      , NotEqual(KAB, $B)
      , NotEqual(KAB, KAS)
      , NotEqual(KAB, ~NA)
      , MyKeyIsSecretA($A, KAS)
      , Forwarded($S, $A, SBMsg1)
      , Forwarded($S, $A, SBMsg2)
      , ForwardedBoth($S, $A, henc(SBMsg1, KAS), henc(SBMsg2, KAS))
      , ForwardedBothUnencrypted(SBMsg1, SBMsg2) ]->
    [ Out(<SBMsg1, SBMsg2>)
    , A_2_State($S, $A, $B, KAS, KAB) ]

rule B_1:
    [ CSKey($B, $S, KBS)
    , In(henc(<KAB, $A>, KBS))
    , Fr(~NB) ]
    --[ NotEqual(KAB, $A)
      , NotEqual($A, $B)
      , NotEqual($A, $S)
      , NotEqual($A, KBS)
      , NotEqual(KAB, $B)
      , NotEqual(KAB, $S)
      , NotEqual(KAB, KBS)
      , MyKeyIsSecretB($B, KBS)
      , Received($S, $B, henc(KAB, KBS), henc($A, KBS)) ]->
    [ Out(henc(~NB, KAB)) 
    , B_1_State($S, $A, $B, KBS, KAB, ~NB) ]

rule A_3:
    [ A_2_State($S, $A, $B, KAS, KAB)
    , In(henc(NB, KAB)) ]
    --[ NotEqual(NB, $A)
      , NotEqual(NB, $B)
      , NotEqual(NB, $S)
      , NotEqual(NB, KAS)
      , NotEqual(NB, KAB)
      , SecretKey($A, KAB)
      , FinishedA($A, $B, KAB) ]->
    [ Out(henc(succ(NB), KAB)) ]

rule B_2:
    [ B_1_State($S, $A, $B, KBS, KAB, ~NB)
    , In(henc(succ(~NB), KAB)) ]
    --[ SecretKey($B, KAB)
      , FinishedB($B, $A, KAB) ]->
    []

restriction notEqual:
    "All a #t. NotEqual(a,a) @t ==> F"

lemma serverKeyNeverForwarded [sources]:
    "All SBMsg1 SBMsg2 #i. ForwardedBothUnencrypted(SBMsg1, SBMsg2) @i ==> (
          (not ( Ex $C $S #t. CSKey($C, $S, SBMsg1) @t ))
        & (not ( Ex $C $S #t. SCKey($S, $C, SBMsg1) @t ))
        & (not ( Ex $C $S #t. CSKey($C, $S, SBMsg2) @t ))
        & (not ( Ex $C $S #t. SCKey($S, $C, SBMsg2) @t ))
    )"

lemma serverKeySecretA [sources]:
    "All $A KAS #i. MyKeyIsSecretA($A, KAS) @i ==> (
        not ( Ex #t. K(KAS) @t )
    )"

lemma serverKeySecretB [sources]:
    "All $B KBS #i. MyKeyIsSecretB($B, KBS) @i ==> (
        not ( Ex #t. K(KBS) @t )
    )"

lemma forwardMessage [sources]:
    "All $S $A m1 m2 #i. ForwardedBoth($S, $A, m1, m2) @i ==> (
          ( Ex #t. Sent($S, $A, m1) @t
            & Sent($S, $A, m2) @t
            & (#t < #i))
        | ( Ex #t. WrongForward($S, $A, m1) @t 
            & WrongForward($S, $A, m2) @t
            & (#t < #i))
    )"
    
lemma receiveForwardedMessage [sources]:
    "All $S $B m1 m2 #i. Received($S, $B, m1, m2) @i ==> (
          ( Ex #t1 #t2. SentToForward($S, $A, $B, m1, m2) @t1 
            & Forwarded($S, $A, m1) @t2
            & Forwarded($S, $A, m2) @t2
            & (#t1 < #t2)
            & (#t2 < #i) )
        | ( Ex #t. Sent($S, $B, m1) @t 
            & Sent($S, $B, m2) @t 
            & (#t < #i) )
    )"

lemma Executability_Lemma:
    exists-trace "Ex A B key #i #j. FinishedA(A, B, key) @i & FinishedB(B, A, key) @j & not (A = B)"

lemma Secret_Shared_Key: 
    "All agent key #i. SecretKey(agent, key) @i ==> (not (Ex #t. K(key) @t))"

end