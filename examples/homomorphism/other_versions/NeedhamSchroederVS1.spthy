// NEEDHAM-SCHROEDER SYMMETRIC KEY PROTOCOL from the Cap Unification paper

theory NeedhamSchroeder
begin

builtins: symmetric-encryption
functions: succ/1

rule Client_Server_Keys:
    [ Fr(~key) ]
    --[]->
    [ !SCKey($Server, $Client, ~key) ]

/*
rule Reveal_Key:
    [ !SCKey(S, C, key) ]
    --[ KeyReveal(key) ]->
    [ Out(key) ]
*/

rule A_1:
    [ !SCKey($S, $A, KAS)
    , Fr(~NA) ]
    --[]->
    [ Out( <<$A, $B>, ~NA> )
    , A_1_State($S, $A, $B, KAS, ~NA) ]

rule S_1:
    [ !SCKey($S, $A, KAS)
    , !SCKey($S, $B, KBS)
    , In( <<$A, $B>, NA> )
    , Fr(~KAB) ]
    --[Sending(senc(<~KAB, $A>, KBS), $S,$A)]->
    [ Out( senc( <<<NA, $B>, ~KAB>, senc(<~KAB, $A>, KBS)>, KAS) ) ]

rule A_2:
    [ A_1_State($S, $A, $B, KAS, ~NA)
    , In( senc( <<<~NA, $B>, KAB>, SBMsg>, KAS) ) ]
    --[Forwarded(SBMsg, $S,$A)]->
    [ Out(SBMsg)
    , A_2_State($S, $A, $B, KAS, KAB) ]

rule B_1:
    [ !SCKey($S, $B, KBS)
    , In(senc(<KAB, $A>, KBS))
    , Fr(~NB) ]
    --[]->
    [ Out(senc(~NB, KAB)) 
    , B_1_State($S, $A, $B, KBS, KAB, ~NB) ]

rule A_3:
    [ A_2_State($S, $A, $B, KAS, KAB)
    , In(senc(NB, KAB)) ]
    --[ Secret($S, $A, $B, KAS, KAB), SecretKey($A, KAB) ]->
    [ Out(senc(succ(NB), KAB)) ]

rule B_2:
    [ B_1_State($S, $A, $B, KBS, KAB, ~NB)
    , In(senc(succ(~NB), KAB)) ]
    --[ Secret($S, $B, $A, KBS, KAB), SecretKey($B, KAB) ]->
    []

/*
lemma Secret_Shared_Key:
    "
    ( All S A B KAS KBS KAB #i #j. 
          Secret(S,A,B,KAS,KAB) @ #i
        & Secret(S,B,A,KBS,KAB) @ #j
        & not (Ex #t1. K(KAS) @ #t1)
        & not (Ex #t2. K(KBS) @ #t2) 
        ==> not (Ex #t3. K(KAB) @ #t3)
    )
    " */


lemma forwardmessage [sources]:
    "
    All S A m #i. 
        Forwarded(m, S, A) @ #i ==> (Ex #t. Sending(m, S, A)@t & (#t < #i))
"

lemma Secret_Shared_Key: 
"All agent key #i. 
SecretKey(agent, key) @ #i ==> (not (Ex #t. K(key) @ #t))"
end