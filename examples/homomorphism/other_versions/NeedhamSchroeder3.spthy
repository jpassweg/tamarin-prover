// NEEDHAM-SCHROEDER SYMMETRIC KEY PROTOCOL from the Cap Unification paper

theory NeedhamSchroederThree
begin

builtins: homomorphic-encryption
functions: succ/1

rule Client_Server_Keys:
    [ Fr(~key) ]
    --[]->
    [ SCKey($Server, $Client, ~key), CSKey($Client, $Server, ~key) ]

rule A_1:
    [ CSKey($A, $S, KAS)
    , Fr(~NA) ]
    --[]->
    [ Out(<<$A, $B>, ~NA>)
    , A_1_State($S, $A, $B, KAS, ~NA) ]

rule S_1:
    [ SCKey($S, $A, KAS)
    , SCKey($S, $B, KBS)
    , In(<<$A, $B>, NA>)
    , Fr(~KAB) ]
    --[ Sending($S, $A, $B, henc(<~KAB, $A>, KBS)) ]->
    [ Out(henc(<<<NA, $B>, ~KAB>, henc(<~KAB, $A>, KBS)>, KAS)) ]

rule A_2:
    [ A_1_State($S, $A, $B, KAS, ~NA)
    , In(henc(<<<~NA, $B>, KAB>, SBMsg>, KAS)) ]
    --[ Forwarded($S, $A, $B, SBMsg) ]->
    [ Out(SBMsg)
    , A_2_State($S, $A, $B, KAS, KAB) ]

rule B_1:
    [ CSKey($B, $S, KBS)
    , In(henc(<KAB, $A>, KBS))
    , Fr(~NB) ]
    --[ Received($S, $A, $B, henc(<KAB, $A>, KBS))]->
    [ Out(henc(~NB, KAB)) 
    , B_1_State($S, $A, $B, KBS, KAB, ~NB) ]

rule A_3:
    [ A_2_State($S, $A, $B, KAS, KAB)
    , In(henc(NB, KAB)) ]
    --[ SecretKey($A, KAB) ]->
    [ Out(henc(succ(NB), KAB)) ]

rule B_2:
    [ B_1_State($S, $A, $B, KBS, KAB, ~NB)
    , In(henc(succ(~NB), KAB)) ]
    --[ SecretKey($B, KAB) ]->
    []

lemma forwardmessage [sources]:
    "All S A B m #i. Forwarded(S, A, B, m) @i ==> (Ex #t. Sending(S, A, B, m) @t & (#t < #i))"

lemma sourceagentb [sources]:
    "All S A B m #i. Received(S, A, B, m) @i ==> (Ex #t. Forwarded(S, A, B, m) @t & (#t < #i))"

lemma Executability_Lemma:
    "Ex agent key #i. SecretKey(agent, key) @i"

lemma Secret_Shared_Key: 
    "All agent key #i. SecretKey(agent, key) @i ==> (not (Ex #t. K(key) @t))"

end