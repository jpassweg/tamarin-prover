

module Term.Unification.UnificationCombinator (
    matchUnionDisjointTheories
  , unifyUnionDisjointTheories
) where

import Term.LTerm (
  LTerm, Lit(Var, Con), IsConst, LVar(..), TermView(FApp, Lit), LSort(..), varTerm, varsVTerm, viewTerm, isAnyHom, termViewToTerm, isLit)

import Term.Rewriting.Definitions (Equal(..), Match, flattenMatch)
import Term.Substitution.SubstVFree (substFromList, applyVTerm, Subst, LSubst)
import Term.Substitution.SubstVFresh (LSubstVFresh, substFromListVFresh, substToListVFresh)

import Term.Unification.MConst
    ( MConst,
      toMConstA,
      toMConstC,
      toMConstVarList,
      fromMConst,
      sortOfMConst )

import Data.Bifunctor (second, bimap)
import Data.List (permutations)
import Extension.Prelude (sortednub)
import Term.Unification.HomomorphicEncryption (getNewSimilarVar, foldVars, eqsToTerms)
import Data.Maybe (mapMaybe)

-- NOTE: Maybe add checks here that in the returned substitution all vars on the left
-- are from the matched terms and all vars on the right are from the term to be matched.
matchUnionDisjointTheories :: IsConst c => (c -> LSort) -> DoubleMConstUnifierPair c -> (Equal (LTerm (MConst c)) -> Bool) -> Match (LTerm c) -> [LSubst c]
matchUnionDisjointTheories sortOf unifierPair isRightSystem matchProblem = case flattenMatch matchProblem of
  Nothing -> []
  Just ms -> let
      eqs = map (\(t,p) -> Equal (toMConstA t) (toMConstC p)) ms
      orgVars = foldVars $ concatMap (\(l,r) -> [l,r]) ms
      highestIndex = foldr (max . lvarIdx) 0 orgVars
      unifier = map substToListVFresh $ unifyUnionDisjointTheories (sortOfMConst sortOf) unifierPair isRightSystem eqs
      newVars = filter (`notElem` orgVars) $
        map fst (concat unifier) ++ concatMap (varsVTerm . snd) (concat unifier)
      newVarsSubst = zipWith (\v newIdx -> (v, LVar (lvarName v) (lvarSort v) newIdx)) newVars [highestIndex+1..]
      newVarsSubst' = substFromList $ map (second varTerm) newVarsSubst
      unifier' = map (map (bimap (varSwap newVarsSubst) (applyVTerm newVarsSubst'))) unifier
    in map (substFromList . map (second fromMConst)) unifier'
    where
      varSwap :: [(LVar,LVar)] -> LVar -> LVar
      varSwap vS v = foldl (\v1 (v2,v3) -> if v1 == v2 then v3 else v1) v vS

-- unifyRaw return must be applied to eqs before adding them here
-- NOTE: cleanSolvedSystem makes sure that new variables generated by the unifiers it holds that: 
-- For All v in (R5,1 u R5,2) / R0 . v not in (R5,1 n R5,2) 
-- i.e. the unifiers don't seperately create the same new variable each
-- NOTE: It is not sure if onlySameSortsPartitions is correct. The idea is that classes
-- as mentioned in Step 3 (variable identification) of the disjoint algorithm only make sense
-- if they all have the same sort. However, sorts are never mentioned in the paper and
-- we therefore might be removing possible solutions. A better solution might be investigating
-- in which sense sorts play a role for classes. As an example, an idea might be that the
-- variable at the start of the list that is chosen as the representant needs to have sort
-- geq any other variable sort in the same class. 
-- OPTIMIZATION:
-- - Remove indexes which for an equation x1 = x2 assign x1 and x2 the same index for x1 and x2
--   being two different variables.  
-- - Investigate which linear orderings make sense "sort wise" and if we can remove some
--   (probably not as it is a restriction which might never occur in the actual substitution)
unifyUnionDisjointTheories :: IsConst c => (c -> LSort) -> MConstUnifierPair c -> (Equal (LTerm c) -> Bool) -> [Equal (LTerm c)] -> [LSubstVFresh c]
unifyUnionDisjointTheories sortOf unifierPair isRightSystem eqs = let
  allVars = foldVars $ eqsToTerms eqs
  (absEqs, absAllVars) = abstractEqs $ abstractVars (eqs, allVars)
  (acSystem, homSystem) = splitSystem isRightSystem absEqs
  solvedSystems = solveDisjointSystems sortOf
    (acSystem, homSystem) unifierPair (filter onlySameSortsPartitions $ getAllPartitions absAllVars)
  in combineDisjointSystems $ cleanSolvedSystem absAllVars solvedSystems

abstractVars :: IsConst c => ([Equal (LTerm c)], [LVar]) -> ([Equal (LTerm c)], [LVar])
abstractVars ([], allVars) = ([], allVars)
abstractVars (e:es, allVars) = case findAlienSubTerm e of
  Just (alienSubterm, applyToOneSide) -> let
    -- NOTE: can be improved to LSortMsg or LSortNat but algorithm then needs to be adapted
    newVar = getNewSimilarVar (LVar "abstractVar" LSortMsg 0) allVars
    newE = applyToOneSide (substituteTermWithVar alienSubterm newVar) e
    in abstractVars (Equal alienSubterm (varTerm newVar) : newE : es, newVar : allVars)
  Nothing -> let (newEs, totVars) = abstractVars (es, allVars)
    in (e : newEs, totVars)
  where
    findAlienSubTerm :: IsConst c => Equal (LTerm c) -> Maybe (LTerm c, (LTerm c -> LTerm c) -> Equal (LTerm c) -> Equal (LTerm c))
    findAlienSubTerm eq = case
        (findAlienSubTerm' (isAnyHom (eqLHS eq)) (eqLHS eq),
        findAlienSubTerm' (isAnyHom (eqRHS eq)) (eqRHS eq)) of
      (Just alienTerm, _) -> Just (alienTerm, \f e' -> Equal (f (eqLHS e')) (eqRHS e'))
      (_, Just alienTerm) -> Just (alienTerm, \f e' -> Equal (eqLHS e') (f (eqRHS e')))
      _                   -> Nothing
    findAlienSubTerm' :: IsConst c => Bool -> LTerm c -> Maybe (LTerm c)
    findAlienSubTerm' b t = case viewTerm t of
      Lit (Var _) -> Nothing
      Lit (Con _) -> Nothing -- ? if isAnyHom t /= b then Just t else Nothing
      FApp _ args -> if isAnyHom t /= b then Just t else case mapMaybe (findAlienSubTerm' b) args of
        []    -> Nothing
        (e':_) -> Just e'
    substituteTermWithVar :: IsConst c => LTerm c -> LVar -> LTerm c -> LTerm c
    substituteTermWithVar tToSub newV t = if tToSub == t then varTerm newV else case viewTerm t of
      Lit (Var _)      -> t
      Lit (Con _)      -> t
      FApp funsym args -> termViewToTerm (FApp funsym (map (substituteTermWithVar tToSub newV) args))

abstractEqs :: IsConst c => ([Equal (LTerm c)], [LVar]) -> ([Equal (LTerm c)], [LVar])
abstractEqs ([], allVars) = ([], allVars)
abstractEqs (e:es, allVars) = if isLit (eqLHS e) || isLit (eqRHS e)
    || isAnyHom (eqLHS e) == isAnyHom (eqRHS e)
  then let (newEs, newVars) = abstractEqs (es, allVars) in (e : newEs, newVars)
  else let
    newVar = getNewSimilarVar (LVar "splitVar" LSortMsg 0) allVars
    (newEs, newVars) = abstractEqs (es, newVar : allVars)
  in (Equal (varTerm newVar) (eqLHS e) : Equal (varTerm newVar) (eqRHS e) : newEs, newVars)

getAllPartitions :: [a] -> [[[a]]]
getAllPartitions [] = [[]]
getAllPartitions (x : xs) = concatMap (insert x) (getAllPartitions xs)
  where
    insert :: a -> [[a]] -> [[[a]]]
    insert x' [] = [[[x']]]
    insert x' (ys : yss) = ((x' : ys) : yss) : map (ys : ) (insert x' yss)

onlySameSortsPartitions :: [[LVar]] -> Bool
onlySameSortsPartitions = all sameSort
  where
    sameSort :: [LVar] -> Bool
    sameSort [] = True
    sameSort (v:vs) = all (hasSort $ lvarSort v) vs
    hasSort :: LSort -> LVar -> Bool
    hasSort s v = s == lvarSort v

splitSystem :: IsConst c => (Equal (LTerm c) -> Bool) -> [Equal (LTerm c)] -> EquationPair c
splitSystem fBool = foldr (\eq (eqL, eqR) -> if fBool eq then (eqL, eq:eqR) else (eq:eqL, eqR)) ([],[])

type EquationPair c = ([Equal (LTerm c)], [Equal (LTerm c)])

type DoubleMConstUnifierPair c = ([Equal (LTerm (MConst (MConst c)))] -> [LSubstVFresh (MConst (MConst c))]
                                , [Equal (LTerm (MConst (MConst c)))] -> [LSubstVFresh (MConst (MConst c))])

type MConstUnifierPair c = ([Equal (LTerm (MConst c))] -> [LSubstVFresh (MConst c)]
                          , [Equal (LTerm (MConst c))] -> [LSubstVFresh (MConst c)])

type VarOrdUnifierPair c = ([[LVar]], [LVar], [(LVar, Int)], [[(LVar, LTerm c)]], [[(LVar, LTerm c)]])

-- Function works through partitions and adapting the system for each one
solveDisjointSystems :: IsConst c => (c -> LSort) -> EquationPair c -> MConstUnifierPair c
  -> [[[LVar]]] -> VarOrdUnifierPair c
solveDisjointSystems _ _ _ [] = ([], [], [], [], [])
solveDisjointSystems sortOf sys unifiers (vP:varPartitions) = let
    sys' = applyVarPartition vP sys
    partitionVars = map head vP
    varIndexes = getAll01Maps partitionVars
  in case solveDisjointSystemsWithPartition sortOf sys' unifiers partitionVars varIndexes of
    Just (_, varOrd, varInd, substL, substR) -> (vP, varOrd, varInd, substL, substR)
    Nothing     -> solveDisjointSystems sortOf sys unifiers varPartitions
  where
    applyVarPartition :: IsConst c => [[LVar]] -> EquationPair c -> EquationPair c
    applyVarPartition [] newSys = newSys
    applyVarPartition (vClass:vClasses) newSys = if length vClass == 1
      then applyVarPartition vClasses newSys
      else applyVarPartition vClasses (applyToSystem (vClassSubst vClass) newSys)
    vClassSubst :: IsConst c => [LVar] -> Subst c LVar
    vClassSubst vClass = substFromList $ map (\v -> (v, varTerm $ head vClass)) (tail vClass)
    applyToSystem :: IsConst c => Subst c LVar -> EquationPair c -> EquationPair c
    applyToSystem subst (sysL, sysR) = ((map . fmap) (applyVTerm subst) sysL,
                                        (map . fmap) (applyVTerm subst) sysR)
    getAll01Maps :: [a] -> [[(a, Int)]]
    getAll01Maps = mapM (\x -> [(x, 0), (x, 1)])

solveDisjointSystemsWithPartition :: IsConst c => (c -> LSort) -> EquationPair c -> MConstUnifierPair c
  -> [LVar] -> [[(LVar, Int)]] -> Maybe (VarOrdUnifierPair c)
solveDisjointSystemsWithPartition _ _ _ _ [] = Nothing
solveDisjointSystemsWithPartition sortOf sys (unifierL, unifierR) vars (vIndex:varIndexes) = let
    (sysWithVarIndexL, sysWithVarIndexR) = applyVarConstToSys vIndex sys
    (solvedSysL, solvedSysR) = (unifierL sysWithVarIndexL, unifierR sysWithVarIndexR)
    solvedSysL' = map (map (second fromMConst) . substToListVFresh) solvedSysL
    solvedSysR' = map (map (second fromMConst) . substToListVFresh) solvedSysR
    (corrP, solvedSysL'', solvedSysR'') =
      getFirstNonEmptyPermutation (permutations vars) (solvedSysL', solvedSysR')
  -- NOTE: Maybe need to check for sorts because vor new variables etc.
  in if not (null solvedSysL)   && not (null solvedSysR)
     && not (null solvedSysL'') && not (null solvedSysR'')
  then Just ([], corrP, vIndex, solvedSysL'', solvedSysR'')
  else solveDisjointSystemsWithPartition sortOf sys (unifierL, unifierR) vars varIndexes
  where
    applyVarConstToSys :: IsConst c => [(LVar, Int)] -> EquationPair c -> EquationPair (MConst c)
    applyVarConstToSys varIndex (sysL, sysR) = let
      vars0 = map fst $ filter (\ind -> snd ind == 0) varIndex
      vars1 = map fst $ filter (\ind -> snd ind == 1) varIndex
      in ((map . fmap) (toMConstVarList vars0) sysL,
          (map . fmap) (toMConstVarList vars1) sysR)
    -- NOTE: can be implemented more efficiently by checking that combined substitution 
    -- is circle free when looking at variabes.
    getFirstNonEmptyPermutation :: IsConst c => [[LVar]]
      -> ([[(LVar, LTerm c)]], [[(LVar, LTerm c)]])
      -> ([LVar], [[(LVar, LTerm c)]], [[(LVar, LTerm c)]])
    getFirstNonEmptyPermutation [] (_, _) = ([], [],[])
    getFirstNonEmptyPermutation (p:ps) (substsL,substsR) = let
        substsL' = linearRestriction p substsL
        substsR' = linearRestriction p substsR
      in if not (null substsL') && not (null substsR')
      -- NOTE: we reverse p as we look at linear restrictions in reverse order
      then (reverse p, substsL', substsR')
      else getFirstNonEmptyPermutation ps (substsL,substsR)
    linearRestriction :: IsConst c => [LVar] -> [[(LVar, LTerm c)]] -> [[(LVar, LTerm c)]]
    linearRestriction p = filter (linearRestriction' p)
    linearRestriction' :: IsConst c => [LVar] -> [(LVar, LTerm c)] -> Bool
    linearRestriction' p = all (\(varL, termR) -> all (\v -> v `notElem` varsVTerm termR) (takeWhile (/= varL) p))

-- NOTE: can add tests here like that left and right substitutions don't have the
-- same variable on the left side
cleanSolvedSystem :: IsConst c => [LVar] -> VarOrdUnifierPair c -> VarOrdUnifierPair c
cleanSolvedSystem orgVars (varPt, varOrd, varInd, substL, substR) = let
    allVarsL = map fst (concat substL) ++ concatMap (varsVTerm . snd) (concat substL)
    newVarsR = filter (`notElem` orgVars) $
      map fst (concat substR) ++ concatMap (varsVTerm . snd) (concat substR)
    highestIndexL = foldr (max . lvarIdx) 0 allVarsL
    newVarsRSubst = zipWith (\v newIdx -> (v, LVar (lvarName v) (lvarSort v) newIdx)) newVarsR [highestIndexL+1..]
    newVarsRSubst' = substFromList $ map (second varTerm) newVarsRSubst
    substR' = map (map (bimap (varSwap newVarsRSubst) (applyVTerm newVarsRSubst'))) substR
  in (varPt, varOrd, varInd, substL, substR')
  where
    varSwap :: [(LVar,LVar)] -> LVar -> LVar
    varSwap vS v = foldl (\v1 (v2,v3) -> if v1 == v2 then v3 else v1) v vS

combineDisjointSystems :: IsConst c => VarOrdUnifierPair c -> [LSubstVFresh c]
combineDisjointSystems (varPt, varOrd, _, substL, substR) = let
  cartesianSubsts = [(l,r) | l <- substL, r <- substR]
  combinedSubst = map (fillSubst varOrd) cartesianSubsts
  completeSubst = map (addPartitionedVar varPt) combinedSubst
  in map substFromListVFresh $ sortednub completeSubst
  where
    fillSubst :: IsConst c => [LVar] -> ([(LVar, LTerm c)], [(LVar, LTerm c)]) -> [(LVar, LTerm c)]
    fillSubst [] _ = []
    fillSubst (v:vs) (preSubstL, preSubstR) = let
        -- NOTE: maybe can be done better 
        substV = filter ((== v) . fst) preSubstL ++ filter ((== v) . fst) preSubstR
      in if null substV
        then fillSubst vs (preSubstL, preSubstR)
        else head substV : map (second (applyVTerm $ substFromList [head substV]))
          (fillSubst vs (preSubstL, preSubstR))
    addPartitionedVar :: IsConst c => [[LVar]] -> [(LVar, LTerm c)] -> [(LVar, LTerm c)]
    addPartitionedVar [] subst = subst
    addPartitionedVar (vClass:vsClasses) subst = let
        rightSide = foldl (\vT (vR, tR) -> if vT == varTerm vR then tR else vT)
          (varTerm $ head vClass) subst
      in addPartitionedVar vsClasses subst ++ map (\v -> (v,rightSide)) (tail vClass)